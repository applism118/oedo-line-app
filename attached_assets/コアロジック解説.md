# 山手線ウォーキングプランナー コアロジック解説

## ルート計算アルゴリズム

アプリケーションのコアとなるのは、出発駅から到着駅までのルートを計算し、各駅の到着時刻、休憩タイミング、総距離などを算出するルート計算アルゴリズムです。この文書では、`calculateRoute`関数の動作原理と実装詳細を解説します。

## 1. データ構造

### 1.1 駅データ

```typescript
export interface Station {
  name: string;       // 駅名
  nextDistance: number; // 次の駅までの距離（km）
}

export const stations: Station[] = [
  { name: "池袋", nextDistance: 1.530 },
  { name: "大塚", nextDistance: 2.295 },
  // ... 他の駅データ
];
```

- 山手線の各駅を時計回りの順序で配列として定義
- 各駅には駅名と次の駅までの距離を格納
- このデータ構造により、任意の2駅間の経路と距離を計算可能

### 1.2 歩行速度データ

```typescript
export interface WalkingSpeed {
  name: string;     // 速度識別子
  speedKmh: number; // 速度（km/h）
  label: string;    // 表示名
}

export const walkingSpeeds: WalkingSpeed[] = [
  { name: "slow", speedKmh: 3, label: "ゆっくり" },
  { name: "normal", speedKmh: 4, label: "普通" },
  { name: "fast", speedKmh: 5, label: "速い" }
];
```

- 3段階の歩行速度を定義
- 時速（km/h）を基に、各駅間の所要時間を計算

## 2. ルート計算関数

```typescript
export const calculateRoute = (
  fromStation: string,    // 出発駅
  toStation: string,      // 到着駅
  speedKmh: number,       // 歩行速度（km/h）
  startTime: Date,        // 出発時刻
  direction: Direction = "clockwise", // 進行方向
  restMinutes: number = 30 // 休憩時間（分）
): { 
  stations: Array<{ name: string; arrivalTime: Date; departureTime?: Date; isRestStation?: boolean }>,
  totalDistance: number 
} => {
  // 実装詳細...
}
```

この関数は、指定されたパラメータに基づいてルートを計算し、各駅の到着時刻、休憩情報、総距離を含む結果を返します。

## 3. アルゴリズムの詳細

### 3.1 駅のインデックス検索

```typescript
const fromIdx = stations.findIndex(s => s.name === fromStation);
const toIdx = stations.findIndex(s => s.name === toStation);

if (fromIdx === -1 || toIdx === -1) {
  throw new Error("Invalid stations");
}
```

- 出発駅と到着駅の配列内のインデックスを取得
- 存在しない駅名が指定された場合はエラーをスロー

### 3.2 ルート配列の初期化

```typescript
const route: Array<{ name: string; arrivalTime: Date; departureTime?: Date; isRestStation?: boolean }> = [];
let currentTime = new Date(startTime);
let totalDistance = 0;

let currentIdx = fromIdx;
route.push({ name: stations[currentIdx].name, arrivalTime: new Date(currentTime), departureTime: new Date(currentTime) });
```

- ルート情報を格納する配列を初期化
- 現在時刻を出発時刻で初期化
- 総距離カウンターを0で初期化
- 最初の駅（出発駅）をルートに追加

### 3.3 ルートの駅を順次計算

```typescript
let stationCount = 1;
while (currentIdx !== toIdx) {
  const distance = stations[currentIdx].nextDistance;
  const timeHours = distance / speedKmh;
  const timeMs = timeHours * 60 * 60 * 1000;

  if (direction === "clockwise") {
    currentIdx = (currentIdx + 1) % stations.length;
  } else {
    currentIdx = (currentIdx - 1 + stations.length) % stations.length;
  }

  // 計算続行...
}
```

- 到着駅に到達するまで、現在駅から次の駅への移動を繰り返す
- 進行方向（時計回りまたは反時計回り）に基づいて次の駅インデックスを計算
- 駅間距離と歩行速度から所要時間を計算
- `%`演算子を使用して円状の山手線での循環を表現

### 3.4 到着時刻と休憩の計算

```typescript
// 前の駅からの歩行時間に基づいて到着時刻を計算
const arrivalTime = new Date(
  (route[route.length - 1].departureTime || route[route.length - 1].arrivalTime).getTime() + timeMs
);

// 5駅ごとに休憩駅を設定（出発駅と到着駅を除く）
const isRestStation = stationCount % 5 === 0 && 
                     stationCount !== 0 && 
                     currentIdx !== toIdx;

// 休憩駅の場合、出発時刻に休憩時間を追加
const departureTime = isRestStation
  ? new Date(arrivalTime.getTime() + restMinutes * 60 * 1000)
  : arrivalTime;
```

- 前の駅からの歩行時間に基づいて到着時刻を計算
- 5駅ごとに休憩駅を設定（出発駅と到着駅を除く）
- 休憩駅では、指定された休憩時間を出発時刻に加算

### 3.5 ルート情報の追加と距離の累積

```typescript
route.push({
  name: stations[currentIdx].name,
  arrivalTime: arrivalTime,
  departureTime: departureTime,
  isRestStation
});

totalDistance += distance;
stationCount++;
```

- 計算した駅情報をルート配列に追加
- 総距離に現在の区間距離を加算
- 駅カウンターをインクリメント

### 3.6 無限ループ防止

```typescript
if (route.length > stations.length && currentIdx !== toIdx) {
  throw new Error("Route calculation error");
}
```

- ルートが全駅数を超えても到着駅に到達していない場合はエラー
- 無限ループを防止するための安全機構

### 3.7 結果の返却

```typescript
return { stations: route, totalDistance };
```

- 計算されたルート情報（各駅の到着/出発時刻と休憩情報）と総距離を返却

## 4. 実装上の工夫点

### 4.1 循環構造の処理

山手線は円形の路線であるため、インデックス計算では`%`演算子を使用して循環を表現しています。これにより、最後の駅の次が最初の駅になる循環構造を簡潔に実装しています。

```typescript
// 時計回りの場合
currentIdx = (currentIdx + 1) % stations.length;

// 反時計回りの場合
currentIdx = (currentIdx - 1 + stations.length) % stations.length;
```

反時計回りの場合は、負のインデックスを防ぐために`+ stations.length`を追加しています。

### 4.2 日付・時刻の扱い

JavaScript/TypeScriptの`Date`オブジェクトは可変（mutable）であるため、日付操作を行う際は常に新しいオブジェクトを作成して参照の問題を防いでいます。

```typescript
// 新しい日付オブジェクトを作成して変更を加える
const arrivalTime = new Date(
  (route[route.length - 1].departureTime || route[route.length - 1].arrivalTime).getTime() + timeMs
);
```

### 4.3 休憩駅の決定ロジック

休憩駅は、単純な数値条件ではなく、複数の条件を組み合わせて決定しています：

```typescript
const isRestStation = stationCount % 5 === 0 && 
                     stationCount !== 0 && 
                     currentIdx !== toIdx;
```

これにより、以下の条件を満たす駅が休憩駅になります：
- 5の倍数番目の駅である（5駅ごと）
- 最初の駅（スタート地点）ではない
- 最後の駅（ゴール地点）ではない

## 5. 利用例

### 5.1 基本的な使用例

```typescript
// 池袋から東京までのルートを計算（時速4km、午前9時出発、時計回り、30分休憩）
const route = calculateRoute(
  "池袋",  // 出発駅
  "東京",  // 到着駅
  4,       // 歩行速度 (km/h)
  new Date("2023-01-01T09:00:00"), // 出発時刻
  "clockwise", // 進行方向
  30      // 休憩時間（分）
);

console.log(`総距離: ${route.totalDistance.toFixed(1)} km`);
console.log(`駅数: ${route.stations.length}`);

// 各駅の詳細を表示
route.stations.forEach(station => {
  console.log(
    `${station.name}: 到着 ${station.arrivalTime.toLocaleTimeString()} ` + 
    (station.isRestStation ? `休憩後出発 ${station.departureTime?.toLocaleTimeString()}` : "")
  );
});
```

### 5.2 異なる速度での比較

```typescript
// 異なる速度でのルート計算結果を比較
const speeds = [3, 4, 5]; // km/h

speeds.forEach(speed => {
  const route = calculateRoute("新宿", "上野", speed, new Date(), "clockwise", 15);
  console.log(`速度 ${speed} km/h: 所要時間約 ${(route.totalDistance / speed).toFixed(1)} 時間`);
});
```

## 6. パフォーマンスと最適化

このアルゴリズムの計算量は、最悪の場合でもO(n)です（nは駅の数）。山手線の駅数は30程度と少ないため、ブラウザ上での計算でもパフォーマンス上の問題はありません。

実際の実装では、以下の最適化が考えられます：

1. **事前計算**: 全ての駅ペア間の距離を事前計算してルックアップテーブルに格納
2. **メモ化**: 同じパラメータでの計算結果をキャッシュ
3. **インクリメンタル更新**: パラメータが部分的に変更された場合のみ、必要な部分だけ再計算

ただし、現在の実装でも十分に高速であるため、これらの最適化は将来的な拡張が必要になった場合に検討すれば十分です。